#!/bin/bash
# Enhanced backup script for TG-RSS with integrity verification
# {{ ansible_managed }}

set -euo pipefail

# Configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
CONFIG_FILE="{{ backup_config_file }}"
LOG_FILE="{{ backup_logs_dir }}/backup.log"
LOCK_FILE="/tmp/tg-rss-backup.lock"
TIMESTAMP=$(date '+%Y%m%d_%H%M%S')
BACKUP_NAME="tg-rss-backup-$TIMESTAMP"
BACKUP_DIR="{{ backup_base_dir }}/$BACKUP_NAME"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Logging functions
log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $*" | tee -a "$LOG_FILE"
}

error() {
    echo -e "${RED}[ERROR]${NC} $*" >&2
    log "ERROR: $*"
}

warning() {
    echo -e "${YELLOW}[WARNING]${NC} $*" >&2
    log "WARNING: $*"
}

success() {
    echo -e "${GREEN}[SUCCESS]${NC} $*" >&2
    log "SUCCESS: $*"
}

# Cleanup function
cleanup() {
    local exit_code=$?
    log "Cleaning up backup process (exit code: $exit_code)"

    # Remove lock file
    rm -f "$LOCK_FILE"

    # Clean up temporary files
    rm -rf "{{ backup_temp_dir }}"

    # Restart services if backup failed
    if [ $exit_code -ne 0 ]; then
        log "Backup failed, attempting to restart services..."
        if command -v docker-compose >/dev/null 2>&1 && [ -f /opt/tg-rss/docker-compose.yml ]; then
            cd /opt/tg-rss
            docker-compose restart 2>/dev/null || warning "Failed to restart services"
        fi
    fi

    exit $exit_code
}

# Set trap for cleanup
trap cleanup EXIT INT TERM

# Check if another backup is running
if [ -f "$LOCK_FILE" ]; then
    error "Another backup process is already running (lock file exists: $LOCK_FILE)"
    exit 1
fi

# Create lock file
touch "$LOCK_FILE"
log "Backup lock acquired"

# Validate configuration
if [ ! -f "$CONFIG_FILE" ]; then
    error "Configuration file not found: $CONFIG_FILE"
    exit 1
fi

log "Starting backup: $BACKUP_NAME"
log "Configuration: $CONFIG_FILE"
log "Backup directory: $BACKUP_DIR"

# Create backup directory
mkdir -p "$BACKUP_DIR"
chmod 750 "$BACKUP_DIR"

# Pre-backup health checks
log "Performing pre-backup health checks..."

# Check disk space
BACKUP_DISK_FREE=$(df "{{ backup_base_dir }}" | tail -1 | awk '{print $4}')
BACKUP_DISK_FREE_MB=$((BACKUP_DISK_FREE / 1024))

if [ $BACKUP_DISK_FREE_MB -lt 1024 ]; then
    error "Insufficient disk space for backup. Available: ${BACKUP_DISK_FREE_MB}MB, Required: 1024MB"
    exit 1
fi

log "Disk space check passed: ${BACKUP_DISK_FREE_MB}MB available"

# Stop application services
log "Stopping application services..."
if command -v docker-compose >/dev/null 2>&1 && [ -f /opt/tg-rss/docker-compose.yml ]; then
    cd /opt/tg-rss
    docker-compose stop
    log "Services stopped successfully"
else
    warning "docker-compose not found or docker-compose.yml not present"
fi

# Backup sources
BACKUP_SOURCES=$(yq eval '.backup_sources[] | select(.enabled != false)' "$CONFIG_FILE" 2>/dev/null || echo "")

if [ -z "$BACKUP_SOURCES" ]; then
    # Fallback to hardcoded sources if yq fails
    log "Using fallback backup sources (yq not available)"
    BACKUP_SOURCES="{{ backup_sources | to_json }}"
fi

# Process each backup source
echo "$BACKUP_SOURCES" | jq -c '.[]' 2>/dev/null | while read -r source; do
    source_name=$(echo "$source" | jq -r '.name')
    source_type=$(echo "$source" | jq -r '.type')
    compress=$(echo "$source" | jq -r '.compress // true')
    verify=$(echo "$source" | jq -r '.verify // true')
    optional=$(echo "$source" | jq -r '.optional // false')

    log "Processing backup source: $source_name (type: $source_type)"

    case $source_type in
        "docker_volume")
            volume_name=$(echo "$source" | jq -r '.volume_name')
            destination=$(echo "$source" | jq -r '.destination')

            if docker volume ls | grep -q "$volume_name"; then
                log "Backing up Docker volume: $volume_name"
                if [ "$compress" = "true" ]; then
                    docker run --rm -v "$volume_name:/data:ro" -v "$BACKUP_DIR:/backup" alpine \
                        tar czf "/backup/${destination}.tar.gz" -C /data . 2>>"$LOG_FILE"
                else
                    docker run --rm -v "$volume_name:/data:ro" -v "$BACKUP_DIR:/backup" alpine \
                        cp -r /data "/backup/$destination" 2>>"$LOG_FILE"
                fi
                success "Docker volume $volume_name backed up"
            else
                if [ "$optional" = "true" ]; then
                    warning "Docker volume $volume_name not found (optional, skipping)"
                else
                    error "Docker volume $volume_name not found"
                    exit 1
                fi
            fi
            ;;

        "directory")
            source_path=$(echo "$source" | jq -r '.source_path')
            destination=$(echo "$source" | jq -r '.destination')

            if [ -e "$source_path" ]; then
                log "Backing up directory: $source_path"
                if [ "$compress" = "true" ]; then
                    tar czf "$BACKUP_DIR/${destination}.tar.gz" -C "$(dirname "$source_path")" "$(basename "$source_path")" 2>>"$LOG_FILE"
                else
                    cp -r "$source_path" "$BACKUP_DIR/$destination" 2>>"$LOG_FILE"
                fi
                success "Directory $source_path backed up"
            else
                if [ "$optional" = "true" ]; then
                    warning "Directory $source_path not found (optional, skipping)"
                else
                    error "Directory $source_path not found"
                    exit 1
                fi
            fi
            ;;

        "file")
            source_path=$(echo "$source" | jq -r '.source_path')
            destination=$(echo "$source" | jq -r '.destination')

            if [ -f "$source_path" ]; then
                log "Backing up file: $source_path"
                cp "$source_path" "$BACKUP_DIR/$destination" 2>>"$LOG_FILE"
                success "File $source_path backed up"
            else
                if [ "$optional" = "true" ]; then
                    warning "File $source_path not found (optional, skipping)"
                else
                    error "File $source_path not found"
                    exit 1
                fi
            fi
            ;;

        *)
            warning "Unknown backup source type: $source_type"
            ;;
    esac
done

# Start services
log "Starting application services..."
if command -v docker-compose >/dev/null 2>&1 && [ -f /opt/tg-rss/docker-compose.yml ]; then
    cd /opt/tg-rss
    docker-compose start
    log "Services started successfully"
fi

# Generate backup manifest
log "Generating backup manifest..."
cat > "$BACKUP_DIR/manifest.txt" << EOF
Backup Name: $BACKUP_NAME
Timestamp: $TIMESTAMP
Created: $(date)
Hostname: $(hostname)
Backup Sources: $(echo "$BACKUP_SOURCES" | jq -r '.[] | .name' | tr '\n' ', ' | sed 's/, $//')
Total Size: $(du -sh "$BACKUP_DIR" | cut -f1)
Checksum: $(find "$BACKUP_DIR" -type f -exec md5sum {} \; | md5sum | cut -d' ' -f1)
EOF

# Integrity verification
if [ "{{ backup_verify_integrity }}" = "true" ]; then
    log "Performing integrity verification..."

    # Verify backup files exist and are readable
    find "$BACKUP_DIR" -type f \( -name "*.tar.gz" -o -name "*.txt" \) | while read -r file; do
        if [ -f "$file" ] && [ -r "$file" ]; then
            # Calculate checksum
            checksum=$(md5sum "$file" | cut -d' ' -f1)
            log "Verified: $(basename "$file") ($checksum)"
        else
            error "Backup file verification failed: $file"
            exit 1
        fi
    done

    success "Integrity verification completed"
fi

# Backup rotation
log "Performing backup rotation..."
"$SCRIPT_DIR/rotate-backups.sh"

# Final status
BACKUP_SIZE=$(du -sh "$BACKUP_DIR" | cut -f1)
log "Backup completed successfully: $BACKUP_NAME"
log "Total size: $BACKUP_SIZE"
log "Location: $BACKUP_DIR"

# Send notification if configured
if [ -n "{{ backup_notification_webhook }}" ]; then
    curl -s -X POST "{{ backup_notification_webhook }}" \
        -H "Content-Type: application/json" \
        -d "{\"text\":\"âœ… TG-RSS Backup completed: $BACKUP_NAME ($BACKUP_SIZE)\"}" || true
fi

success "Backup process completed: $BACKUP_NAME"
echo "$BACKUP_DIR" > /tmp/last_backup_path